# Ход мыслей и анализ подходов (Lab 4)

## 1) Где в реальных библиотеках есть динамические свойства контекста

Примеры из распространенных экосистем:

- ASP.NET Core: `HttpContext.Items`
- ASP.NET Core auth: `AuthenticationProperties.Items`
- ASP.NET MVC: `ActionExecutingContext.ActionParameters`
- FluentValidation: `ValidationContext.RootContextData`
- HotChocolate GraphQL: `IResolverContext.ContextData`

Общая идея: библиотека задает только контейнер данных, а конкретные ключи/значения задают потребители, которым нужна дополнительная информация, неизвестная библиотеке заранее.

## 2) Почему FatStruct не подходит библиотеке, не знающей пользователей

`FatStruct` означает заранее фиксированный набор полей (часто очень большой), например:

- `int health`
- `str role`
- `float speed`
- ...

Почему это плохо в библиотеке:

1. Библиотека не знает, какие поля потребуются всем будущим потребителям.
2. Любое новое поле требует изменения контракта библиотеки и релиза новой версии.
3. Большая часть полей будет пустовать у многих пользователей (лишняя память).
4. Пользователь не может расширить модель "снаружи", не меняя библиотеку.

Итог: `FatStruct` годится для закрытого домена с известной схемой, но плохо масштабируется как универсальный библиотечный контракт.

## 3) Рассмотренные подходы

### Иерархии классов

- Плюсы: строгая типизация.
- Минусы: статическая структура, сложность расширения, рост количества классов.

### `object[]` + теги

- Плюсы: просто, компактно.
- Минусы: слабая читабельность, ручные касты, риск перепутать индексы/теги.

### Ассоциативный массив (выбран)

- Плюсы: динамичность, гибкость, естественно для библиотечного "контекстного" API.
- Минусы: нужен контроль ключей и типов, иначе легко сломать совместимость.

### ECS (sparse set / archetype)

- Плюсы: высокая производительность для большого количества сущностей.
- Минусы: значительно сложнее, избыточно для учебной демонстрации API-контекста.

## 4) Что выбрано в этой лабораторной

Выбран словарь с типизированным ключом:

- `TypedKey[T]` содержит:
  - `id: int` (внутренний ключ хранения),
  - `name: str` (глобальное имя),
  - `value_type`.
- `DynamicContext` хранит значения по `id` ключа.
- `Entity` из библиотеки имеет динамические `properties`.
- `EntityPipeline` выполняет операции, заданные потребителем.

## 5) Как обеспечена совместимость между проектами

Введен `GLOBAL_KEY_REGISTRY`:

- при регистрации ключа с уже занятым именем:
  - если тип совпадает, возвращается существующий ключ;
  - если тип отличается, выбрасывается `KeyConflictError`.

Это защищает от ситуации:

- проект A пишет `game.health` как `int`,
- проект B пишет `game.health` как `str`.

## 6) Что показывает демо

1. Проект-потребитель A:

- создает сущность из библиотечного типа;
- добавляет свои свойства;
- задает операции pipeline.

2. Проект-потребитель B:

- повторно использует существующий ключ;
- получает ошибку при попытке зарегистрировать тот же ключ с другим типом.

Таким образом достигнута цель задания: библиотека изолирована, но позволяет внешним проектам расширять данные и поведение через динамический контекст.

